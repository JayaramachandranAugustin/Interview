# Bucket Sort

Author - [Jayaramachandran Augustin](https://www.linkedin.com/in/jayaramachandran-augustin-bbb754109/).

In this lesson we will see about bucket sort algorithm, Bucket sorting algorithm is also known as bin sort. Bucket sort comes very handy if you can able to logically group the input array to a number of buckets uniformly. Once the data is uniformly distributed across each bucket, each bucket is individually sorted using a sorting algorithm and then visit each bucket in  order then place each bucket to array.
The time complexity of the algorithm heavily depends on how well the input array is distributed across the buckets.
We will see this with an example.

  1. First start with creating and distributing the input across the buckets. Use better hash function to achieve this. This is very important step in the bucket sort. If all the elements are placed in a single bucket. Then, it will become normal sorting.
  In this case, we know the upper and lower limit of the input variable. A easy and better hash function is create a 10 bucket and place it in the bucket based on the tenth place integer value.
  Let take we need to sort a input array whose value will be ranging from 0 to 99. 56, 34, 89, 45, 23, 65, 33, 12, 9, 48, 72, 96.


    Bucket 0 -   [9]
    Bucket 1 -   [12]
    Bucket 2 -   [23]
    Bucket 3 -   [33, 34]
    Bucket 4 -   [45, 48]
    Bucket 5 -   [56]
    Bucket 6 -   [65]
    Bucket 7 -   [72]
    Bucket 8 -   [89]
    Bucket 9 -   [96]
  2. Use insertion sort to sort each bucket.


    Bucket 0 -   [9]
    Bucket 1 -   [12]
    Bucket 2 -   [23]
    Bucket 3 -   [33, 34]
    Bucket 4 -   [48, 45]
    Bucket 5 -   [56]
    Bucket 6 -   [65]
    Bucket 7 -   [72]
    Bucket 8 -   [89]
    Bucket 9 -   [96]
  3. Once all the buckets are sorted visit each bucket in order, then place each bucket to array.

  >  9 12 23 33 34 45 48 56 65 72 89 96 

__Time complexity analysis:__
Bucket sort can be used efficiently only if we can uniformly distribute the input across buckets. When the input contains several keys which are generated by hash function that are close to each other (clustering), in that case all the elements are placed in the same bucket. The worst-case scenario occurs when all the elements are placed in a single bucket. The overall performance would then be dominated by the algorithm used to sort each bucket, which is typically 	insertion sort, making bucket sort less optimal than O(nlog(n)) comparison sort algorithms like Quicksort.

If the data is uniformly distributed across the buckets, then the time complexity of the bucket sort is O(n)



```JAVA
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class BucketSort {
	  public int hash(int value){
		    return value/10;
		  }
		  public List<Integer> bucketSort(int[] list){
		    List<Integer> result=new ArrayList<>();
		    List<List<Integer>> buckets=new ArrayList<>(10);
		    for(int i=0;i<10;i++) {
		    	buckets.add(new ArrayList<>());
		    }
		    for(int value:list){
		      int key=hash(value);
		      buckets.get(key).add(value);
		    }

		    for(int i=0;i<buckets.size();i++){
		      if(buckets.get(i)!=null){
		        Collections.sort(buckets.get(i));
		        result.addAll(buckets.get(i));
		      }
		    }
		    return result;
		  }
		  public static void main(String args[]){
		    int[] input={56, 34, 89, 45, 23, 65, 33, 12, 9, 48, 72, 96};
		    for(int value:new BucketSort().bucketSort(input)){
		      System.out.print(value+" ");
		    }
		  }
}

```
